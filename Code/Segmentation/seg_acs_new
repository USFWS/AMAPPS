# Function to segment continuous survey data in AMAPPS database
# Returns wide-form dataframe with segmented data

# Requires observation table with lat/long for each sighting, and spatial lines shapefile containing survey effort

# Calculates species counts by default; set occurences = TRUE for number of flock sightings
# maxDist argument sets maximum allowable distance (approx. meters) between an observation and its nearest segment line
# Segment midpoints fall on track line by default; set centroids = TRUE to use geographic centroid
# seg.min sets minimum allowable segment length

# Distances are in nautical miles

# Kyle Dettloff
# 06-17-2016

suppressMessages(library(maptools))
suppressMessages(library(rgeos))
suppressMessages(library(geosphere))
suppressMessages(library(dplyr))
suppressMessages(library(tidyr))
suppressMessages(library(zoo))

options(dplyr.show_progress = FALSE)

# read in observation and track tables
load("Q:/Kyle_Working_Folder/Segmentation/Atlantic_Coast_Surveys/Data/AMAPPS.RData")

segmentAMAPPS = function(observations, tracks, seg.length = 2.5, seg.tol = 0.5, seg.min = seg.length * seg.tol,
                         centroids = FALSE, maxDist = NA, occurences = FALSE) {

  # -------- segment track data ---------------------------------------------------------------------------------------------------
  seg = tracks %>% select(-c(Crew, Seat)) %>% arrange(SurveyNbr, Transect, Replicate, Obs, Year, Month, Day, Sec) %>%
    mutate(Piece = ifelse(Type %in% c("BEGTRAN", "BEGCNT"), 1, 0)) %>%
    group_by(SurveyNbr, Transect, Replicate, Obs) %>% mutate(Piece = cumsum(Piece)) %>%
    distinct(Long, Lat, Piece, Replicate, Obs, Transect, SurveyNbr) %>%
    group_by(SurveyNbr, Transect, Replicate, Obs, Piece) %>%
    mutate(long_i = lag(Long, default = first(Long), order_by = Sec),
           lat_i = lag(Lat, default = first(Lat), order_by = Sec)) %>%
    rowwise %>% mutate(dist = distVincentySphere(c(long_i, lat_i), c(Long, Lat)) / 1852) %>%
    select(-c(long_i, lat_i, Sec)) %>% ungroup %>% group_by(SurveyNbr, Transect, Replicate, Obs, Piece) %>%
    # calculate cumulative distance traveled between waypoints
    mutate(dist_cuml = cumsum(dist), dist_total = max(dist_cuml)) %>% select(-dist) %>%
    # calculate number of segments for each transect
    mutate(nseg = ifelse(dist_total <= seg.length, 1,
                         ifelse(dist_total / seg.length - floor(dist_total / seg.length) >= seg.tol,
                                floor(dist_total / seg.length) + 1, floor(dist_total / seg.length))),
           # number segments with waypoints
           seg_num = ifelse(dist_cuml <= seg.length | nseg == 1, 1,
                            ifelse(dist_cuml <= seg.length * nseg, ceiling(dist_cuml / seg.length), nseg)),
           # determine number of segments without waypoints
           tot_empty = as.integer(nseg - n_distinct(seg_num)))
  
  # create rows for segments without waypoints  
  seg_empty = seg %>% select(SurveyNbr, Transect, Replicate, Obs, Piece, dist_total, nseg, tot_empty) %>%
    distinct %>% ungroup %>% filter(tot_empty > 0) %>% slice(rep(row_number(), tot_empty)) %>% select(-tot_empty) %>%
    mutate(empty_seg = 1)
  
  # combine segments with and without waypoints
  seg_all = seg %>% select(-tot_empty) %>% bind_rows(., seg_empty) %>% group_by(SurveyNbr, Transect, Replicate, Obs, Piece) %>%
    # number segments without waypoints
    mutate(seg_num = replace(seg_num, is.na(seg_num), setdiff(1:first(nseg), seg_num)),
           # calculate segment lengths
           seg_dist = ifelse(nseg == 1, dist_total,
                             ifelse(seg_num < nseg, seg.length,
                                    ifelse(seg_num == nseg, dist_total - seg.length * (nseg - 1),
                                           seg.length + dist_total - nseg * seg.length))),
           # calculate cumulative segment distance
           seg_dist_cuml = ifelse(seg_num == nseg, dist_total, seg.length * seg_num)) %>%
    select(-dist_total) %>%
    ungroup %>% arrange(SurveyNbr, Transect, Replicate, Obs, Piece, seg_num, dist_cuml) %>%
    group_by(SurveyNbr, Transect, Replicate, Obs, Piece) %>% mutate(dist_cuml = na.locf(dist_cuml)) %>%
    group_by(SurveyNbr, Transect, Replicate, Obs, Piece, seg_num) %>%
    mutate(seg_brk = as.integer(ifelse(row_number() == n() & seg_num != nseg, 1, 0))) %>%
    select(-nseg) %>% group_by(SurveyNbr, Transect, Replicate, Obs, Piece) %>%
    mutate(Long = na.locf(Long), Lat = na.locf(Lat),
           long_lead = na.locf(lead(Long), na.rm = FALSE, fromLast = TRUE),
           lat_lead = na.locf(lead(Lat), na.rm = FALSE, fromLast = TRUE)) %>%
    rowwise %>%
    # calculate heading between last waypoint and segment endpoint
    mutate(heading = as.numeric(ifelse(seg_brk == 0, NA, bearing(c(Long, Lat), c(long_lead, lat_lead), f = 0)))) %>%
    select(-c(seg_brk, long_lead, lat_lead)) %>% ungroup %>%
    group_by(SurveyNbr, Transect, Replicate, Obs, Piece, dist_cuml) %>% mutate(heading = last(heading)) %>%
    group_by(SurveyNbr, Transect, Replicate, Obs, Piece, seg_num) %>%
    # calculate distance between last waypoint and segment endpoint
    mutate(dist_shy = as.numeric(ifelse(is.na(heading), NA, seg_dist_cuml - dist_cuml))) %>%
    rowwise %>%
    # calculate coordinates of segment endpoints
    mutate(coords_end = ifelse(is.na(heading), list(NA), list(destPoint(c(Long, Lat), heading, dist_shy * 1852, f = 0)))) %>%
    select(-c(heading, dist_shy)) %>% ungroup
  
  # create rows for segment endpoints
  end_pts = seg_all %>% select(-empty_seg) %>% filter(!is.na(coords_end)) %>%
    mutate(Long = unlist(lapply(coords_end, `[[`, 1)), Lat = unlist(lapply(coords_end, `[[`, 2)), dist_cuml = seg_dist_cuml) %>%
    select(-c(coords_end, seg_dist_cuml))
  # create rows for segment start points and combine with segment endpoints
  seg_ends = end_pts %>% select(-seg_dist) %>% mutate(seg_num = seg_num + 1) %>% bind_rows(end_pts, .)
  
  # combine segment start points and endpoints with other waypoints
  seg_all_new = seg_all %>% filter(is.na(empty_seg)) %>% select(-c(empty_seg, seg_dist_cuml, coords_end)) %>%
    bind_rows(., seg_ends) %>% arrange(SurveyNbr, Transect, Replicate, Obs, Piece, seg_num, dist_cuml) %>% select(-dist_cuml) %>%
    group_by(SurveyNbr, Transect, Replicate, Obs, Piece, seg_num) %>%
    mutate(seg_dist = round(first(seg_dist[!is.na(seg_dist)]), 3),
           id = paste(SurveyNbr, Transect, Replicate, Obs, Piece, seg_num, sep = "-"),
           transect_id = paste(SurveyNbr, Transect, Replicate, Obs, sep = "-")) %>%
    group_by(SurveyNbr, Transect, Replicate) %>%
    mutate(Year = first(Year[!is.na(Year)]), Month = first(Month[!is.na(Month)]), Day = first(Day[!is.na(Day)])) %>%
    filter(seg_dist >= seg.min) %>% ungroup %>% select(-Piece)
  
  # -------- calculate segment midpoints ------------------------------------------------------------------------------------------
  # create dataframe suitable to become spatial lines object 
  listLines = function(df) {
    df %>% select(Long, Lat) %>% as.data.frame %>% Line %>% list
  }
  
  linelist = seg_all_new %>% group_by(transect_id, id) %>% do(coords = listLines(.))
  # create spatial lines dataframe from segment waypoints and assign ID to each segment
  lineframe = mapply(x = linelist$coords, ids = linelist$id, function(x, ids) Lines(x, ids)) %>% SpatialLines %>%
    SpatialLinesDataFrame(., as.data.frame(select(linelist, transect_id)), match.ID = FALSE)
  
  if (centroids == TRUE) {
    # obtain geographic centroids
    midpoints = gCentroid(lineframe, byid = TRUE) %>% as.data.frame %>% rename(mid_long = x, mid_lat = y) %>% add_rownames("id")
  }
  else if (centroids == FALSE) {
    # obtain segment midpoints
    midpoints = getSpatialLinesMidPoints(lineframe) %>% as.data.frame %>% rename(mid_long = Long, mid_lat = Lat) %>%
      mutate(id = sapply(slot(lineframe, "lines"), function(x) slot(x, "ID")))
  }
  
  # merge segment midpoints with transect information
  seg_mids = seg_all_new %>% select(-c(Long, Lat, GpsError, Type, Condition)) %>% distinct %>%
    group_by(SurveyNbr, Transect, Replicate, Obs) %>% mutate(seg_num = seq.int(n())) %>% ungroup %>%
    left_join(., midpoints, by = "id") %>% select(-c(id, transect_id, Day))
  
  # -------- assign segments to points --------------------------------------------------------------------------------------------
  # function modified from maptools::snapPointsToLines
  assignPointsToLines = function(points, lines, maxDist = NA) {
    
    # remove observations farther than maxDist from segment
    if (!is.na(maxDist)) {
      w = gWithinDistance(points, lines, dist = maxDist, byid = TRUE)
      validPoints = apply(w, 2, any)
      validLines = apply(w, 1, any)
      points = points[validPoints, ]
      lines = lines[validLines, ]
    }
    
    d = gDistance(points, lines, byid = TRUE) # distance matrix of each point to each segment
    nearest_line_index = apply(d, 2, which.min) # position of each nearest segment in lines object
    
    # recover lines' IDs (IDs and index differ if maxDist is given)
    if (!is.na(maxDist)) seg_num = as.numeric(rownames(d)[nearest_line_index]) + 1
    else seg_num = nearest_line_index
    
    # create data frame
    cbind(points@data, seg_num)
  }
  
  # wrapper function to restrict point to line pairing by transect ID
  obs2Lines = function(df, lineframe) {
    
    # define projection
    projHOM = "+proj=omerc +lonc=-75 +lat_0=35 +alpha=40 +k_0=0.9996 +ellps=GRS80 +datum=NAD83"
    
    points = df %>% as.data.frame
    coordinates(points) = c("Long", "Lat")
    proj4string(points) = CRS("+proj=longlat")
    points = spTransform(points, CRS(projHOM))
    
    lines = lineframe[lineframe@data$transect_id == df$transect_id[1], ]
    proj4string(lines) = CRS("+proj=longlat")
    lines = spTransform(lines, CRS(projHOM))
    
    assignPointsToLines(points, lines, maxDist)
  }
  
  # prepare observation table
  obs_transect_id = lineframe@data$transect_id
  obs = observations %>%
    select(SurveyNbr, Transect, Replicate, Obs, Year, Month, Species, FlockSize, Long, Lat) %>%
    # narrow observations to birds
    filter(!(Species %in% c("GRST", "KRST", "LEST", "LOST", "CNRA", "GWSH", "HASH", "MARA",
                            "BODO", "DOLP", "FIWH", "GRSE", "HUWH", "MIWH", "PIWH", "PORP",
                            "RIDO", "RIWH", "WIMA", "SEAL", "WHAL", "UNMM", "UNSD", "SHAR",
                            "UNRA", "UIST", "BALN"))) %>%
    mutate(transect_id = paste(SurveyNbr, Transect, Replicate, Obs, sep = "-")) %>%
    filter(transect_id %in% obs_transect_id)
  # for each transect, find nearest segment to each point
  seg_obs = obs %>% group_by(transect_id) %>% do(obs2Lines(., lineframe)) %>% ungroup %>%
    select(-transect_id)
  
  # join segment midpoints and observations
  segmented = full_join(seg_mids, seg_obs, by = c("SurveyNbr", "Transect", "Replicate", "Obs", "Year", "Month", "seg_num")) %>%
    mutate(FlockSize = replace(FlockSize, is.na(FlockSize), 0), Species = replace(Species, is.na(Species), "NONE"))
  
  # -------- summarize species data by segment and convert to wide form -----------------------------------------------------------
  seg_final = segmented %>%
    group_by(SurveyNbr, Transect, Replicate, Obs, Year, Month, seg_num, seg_dist, mid_long, mid_lat, Species)
  
    if (occurences == FALSE) {
      # total species count
      seg_final = seg_final %>% summarise(FlockSize = sum(FlockSize)) %>%
        spread(Species, FlockSize, fill = 0) %>% select(everything(), -matches("NONE")) %>% ungroup
    }
      else if (occurences == TRUE) {
      # number of species occurences
      seg_final = seg_final %>% select(-FlockSize) %>% summarise(noccur = n()) %>%
        spread(Species, noccur, fill = 0) %>% select(everything(), -matches("NONE")) %>% ungroup
    }
}

### example run ###
seg.amapps = segmentAMAPPS(observations, tracks)
